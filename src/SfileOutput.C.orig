//  SW4 LICENSE
// # ----------------------------------------------------------------------
// # SW4 - Seismic Waves, 4th order
// # ----------------------------------------------------------------------
// # Copyright (c) 2013, Lawrence Livermore National Security, LLC.
// # Produced at the Lawrence Livermore National Laboratory.
// #
// # Written by:
// # N. Anders Petersson (petersson1@llnl.gov)
// # Bjorn Sjogreen      (sjogreen2@llnl.gov)
// #
// # LLNL-CODE-643337
// #
// # All rights reserved.
// #
// # This file is part of SW4, Version: 1.0
// #
// # Please also read LICENCE.txt, which contains "Our Notice and GNU General Public License"
// #
// # This program is free software; you can redistribute it and/or modify
// # it under the terms of the GNU General Public License (as published by
// # the Free Software Foundation) version 2, dated June 1991.
// #
// # This program is distributed in the hope that it will be useful, but
// # WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
// # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
// # conditions of the GNU General Public License for more details.
// #
// # You should have received a copy of the GNU General Public License
// # along with this program; if not, write to the Free Software
// # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
#include "mpi.h"

#include "EW.h"
#include "Require.h"
#include "SfileOutput.h"
#include <fcntl.h>
#include <ctime>
#include <cstring>
#include <unistd.h>

// static variable definition (in class only declaration):
int SfileOutput::mPreceedZeros = 0;

SfileOutput* SfileOutput::nil=static_cast<SfileOutput*>(0);

//-----------------------------------------------------------------------
SfileOutput::SfileOutput( EW* a_ew,
                          float_sw4 time,
                          float_sw4 timeInterval,
                          int cycle,
                          int cycleInterval,
                          float_sw4 tstart,
                          const std::string& filePrefix,
                          int sampleFactor,
                          bool doubleMode ):
  mTime(time),
  mEW(a_ew),
  m_time_done(false),
  mTimeInterval(timeInterval),
  mWritingCycle(cycle),
  mCycleInterval(cycleInterval),
  mFilePrefix(filePrefix),
  mImageSamplingFactor(sampleFactor),
  /* mMode(mode), */
  mFileName(""),
  //   mCycle(-1),
  mNextTime(0.0),
  mStartTime(tstart),
  m_isDefinedMPIWriters(false),
  m_double(doubleMode),
  m_winallocated(false),
  m_isCreated(false),
  m_memallocated(false)
{

  m_att = mEW->usingAttenuation();
}

//-----------------------------------------------------------------------
SfileOutput::~SfileOutput()
{
  if( m_memallocated )
  {
    if( m_double )
      for( unsigned int g=0; g < m_doubleField.size() ; g++ )
        delete[] m_doubleField[g];
    else
      for( unsigned int g=0; g < m_floatField.size() ; g++ )
        delete[] m_floatField[g];
  }
  if( m_winallocated )
    for( int g=0 ; g < mEW->mNumberOfGrids ; g++ )
    {
      delete[] mWindow[g];
      delete[] mGlobalDims[g];
    }
}

//-----------------------------------------------------------------------
//void SfileOutput::set_start_time(double tStart)
//{
//   mStartTime = tStart;
//}

//-----------------------------------------------------------------------
void SfileOutput::setup_images( )
{
  if( !m_winallocated )
  {
    mWindow.resize(mEW->mNumberOfGrids);
    mGlobalDims.resize(mEW->mNumberOfGrids);
    for( int g=0; g < mEW->mNumberOfGrids ; g++ )
    {
      mWindow[g] = new int[6];
      mGlobalDims[g] = new int[6];
    }
    m_winallocated = true;
  }
  for( int g=0 ; g < mEW->mNumberOfGrids ; g++ )
  {
    mWindow[g][0] = mEW->m_iStartInt[g];
    mWindow[g][1] = mEW->m_iEndInt[g];
    mWindow[g][2] = mEW->m_jStartInt[g];
    mWindow[g][3] = mEW->m_jEndInt[g];
    mWindow[g][4] = mEW->m_kStartInt[g];
    mWindow[g][5] = mEW->m_kEndInt[g];


    mGlobalDims[g][0] = 1;
    mGlobalDims[g][1] = mEW->m_global_nx[g];
    mGlobalDims[g][2] = 1;
    mGlobalDims[g][3] = mEW->m_global_ny[g];
    mGlobalDims[g][4] = mWindow[g][4];
    mGlobalDims[g][5] = mWindow[g][5];

// For now, the 3D image is assumed to span the entire computational domain
    m_ihavearray.resize( mEW->mNumberOfGrids );
    m_ihavearray[g] = true;

    // Coarsen grid a number of levels
    if( mImageSamplingFactor > 1 && m_ihavearray[g] )
    {
      for( int dim=0; dim < 3; dim++ )
      {
        int remainder = (mWindow[g][2*dim] -mGlobalDims[g][2*dim])% mImageSamplingFactor;
        if( remainder != 0 )
          mWindow[g][2*dim] += mImageSamplingFactor-remainder;
        remainder = (mWindow[g][2*dim+1] -mGlobalDims[g][2*dim])% mImageSamplingFactor;
        if( remainder != 0 )
          mWindow[g][2*dim+1] -= remainder;

        remainder = (mGlobalDims[g][2*dim+1] -mGlobalDims[g][2*dim])% mImageSamplingFactor;
        if( remainder != 0 )
          mGlobalDims[g][2*dim+1] -= remainder;
      }
    }
  }

  // If there is a glitch, avoid it by adding an extra point to the z-direction
  m_extraz.resize( mEW->mNumberOfGrids );
  m_extraz[0] = 0;
  // Feature disabled
  //   for( int g=1 ; g < mEW->mNumberOfGrids ; g++ )
  //   {
  //      m_extraz[g] = 0;
  //      if( mEW->m_zmin[g] + (mWindow[g][5]-1)*mEW->mGridSize[g] <
  //          mEW->m_zmin[g-1] + (mWindow[g-1][4]-1)*mEW->mGridSize[g-1] )
  //	 m_extraz[g] = 1;
  //   }

  if( m_double )
  {
    m_doubleField.resize( mEW->mNumberOfGrids );
    for( int g = 0 ; g < mEW->mNumberOfGrids ; g++ )
    {
      if( m_ihavearray[g] )
      {
        size_t npts     = ((size_t)(mWindow[g][1] - mWindow[g][0])/mImageSamplingFactor + 1)*
                          ( (mWindow[g][3] - mWindow[g][2])/mImageSamplingFactor + 1)*
                          ( (mWindow[g][5] - mWindow[g][4])/mImageSamplingFactor + 1 + m_extraz[g]);
        m_doubleField[g] = new double[npts];
      }
      else
        m_doubleField[g] = new double[1];
    }
  }
  else
  {
    m_floatField.resize( mEW->mNumberOfGrids );
    for( int g = 0 ; g < mEW->mNumberOfGrids ; g++ )
    {
      if( m_ihavearray[g] )
      {
        size_t npts     = ((size_t)(mWindow[g][1] - mWindow[g][0])/mImageSamplingFactor + 1)*
                          ( (mWindow[g][3] - mWindow[g][2])/mImageSamplingFactor + 1)*
                          ( (mWindow[g][5] - mWindow[g][4])/mImageSamplingFactor + 1 + m_extraz[g]);
        m_floatField[g] = new float[npts];
      }
      else
        m_floatField[g] = new float[1];
    }
  }
  m_memallocated = true;
  define_pio();
}

//-----------------------------------------------------------------------
void SfileOutput::define_pio( )
{
  int glow = 0, ghigh = mEW->mNumberOfGrids;
  m_parallel_io = new Parallel_IO*[ghigh-glow+1];
  for( int g=glow ; g < ghigh ; g++ )
  {
    int global[3], local[3], start[3];
    for( int dim=0 ; dim < 3 ; dim++ )
    {
      global[dim] = (mGlobalDims[g][2*dim+1]-mGlobalDims[g][2*dim])/mImageSamplingFactor+1;
      local[dim]  = (mWindow[g][2*dim+1]-mWindow[g][2*dim])/mImageSamplingFactor+1;
      start[dim]  = (mWindow[g][2*dim]-mGlobalDims[g][2*dim])/mImageSamplingFactor;
    }
    global[2] += m_extraz[g];
    local[2]  += m_extraz[g];

    int iwrite = 0;
    int nrwriters = mEW->getNumberOfWritersPFS();
    int nproc=0, myid=0;
    MPI_Comm_size( MPI_COMM_WORLD, &nproc );
    MPI_Comm_rank( MPI_COMM_WORLD, &myid);

    // new hack
    int* owners = new int[nproc];
    int i=0;
    for( int p=0 ; p<nproc ; p++ )
      if( m_ihavearray[g] )
        owners[i++] = p;
    if( nrwriters > i )
      nrwriters = i;

    if( nrwriters > nproc )
      nrwriters = nproc;
    int q, r;
    if( nproc == 1 || nrwriters == 1 )
    {
      q = 0;
      r = 0;
    }
    else
    {
      q = (nproc-1)/(nrwriters-1);
      r = (nproc-1) % (nrwriters-1);
    }
    for( int w=0 ; w < nrwriters ; w++ )
      if( q*w+r == myid )
        iwrite = 1;
//      std::cout << "Define PIO: grid " << g << " myid = " << myid << " iwrite= " << iwrite << " start= "
    //		<< start[0] << " " << start[1] << " " << start[2] << std::endl;
    m_parallel_io[g-glow] = new Parallel_IO( iwrite, mEW->usingParallelFS(), global, local, start );
    delete[] owners;
  }
  m_isDefinedMPIWriters = true;
}

//-----------------------------------------------------------------------
void SfileOutput::setSteps(int a_steps)
{
  char buffer[50];
  mPreceedZeros = snprintf(buffer, 50, "%d", a_steps );
}

//-----------------------------------------------------------------------
//void SfileOutput::set_double(bool val)
//{
//   m_double = val;
//}

//-----------------------------------------------------------------------
bool SfileOutput::timeToWrite( float_sw4 time, int cycle, float_sw4 dt )
{
  // -----------------------------------------------
  // Check based on cycle
  // -----------------------------------------------
  //   cout << "in time to write " << mWritingCycle << " " << mCycleInterval << " " << " " << mTime << " " <<  mTimeInterval << " " << endl;
  bool do_it=false;
  if( cycle == mWritingCycle )
    do_it = true;
  if( mCycleInterval !=  0 && cycle%mCycleInterval == 0 && time >= mStartTime)
    do_it = true;

  // ---------------------------------------------------
  // Check based on time
  // ---------------------------------------------------
  if(mTime > 0.0 && (  mTime <= time + dt*0.5 ) && !m_time_done )
  {
    m_time_done = true;
    do_it = true;
  }
  if( mTimeInterval != 0.0 && mNextTime <= time + dt*0.5 )
  {
    mNextTime += mTimeInterval;
    if (time >= mStartTime) do_it =  true;
  }
  return do_it;
}

//-----------------------------------------------------------------------
void SfileOutput::update_image( int a_cycle, float_sw4 a_time, float_sw4 a_dt, vector<Sarray>& a_U,
                                vector<Sarray>& a_Rho, vector<Sarray>& a_Mu, vector<Sarray>& a_Lambda,
                                vector<Sarray>& a_gRho, vector<Sarray>& a_gMu, vector<Sarray>& a_gLambda,
                                vector<Sarray>& a_Qp, vector<Sarray>& a_Qs,
                                std::string a_path, std::vector<Sarray>& a_Z )
{
  if( timeToWrite( a_time, a_cycle, a_dt ) )
    force_write_image(a_time, a_cycle, a_U, a_Rho, a_Mu, a_Lambda, a_gRho, a_gMu, a_gLambda, a_Qp, a_Qs, a_path, a_Z);
}

//-----------------------------------------------------------------------
void SfileOutput::force_write_image( float_sw4 a_time, int a_cycle, vector<Sarray>& a_U,
                                     vector<Sarray>& a_Rho, vector<Sarray>& a_Mu, vector<Sarray>& a_Lambda,
                                     vector<Sarray>& a_gRho, vector<Sarray>& a_gMu, vector<Sarray>& a_gLambda,
                                     vector<Sarray>& a_Qp, vector<Sarray>& a_Qs,
                                     std::string a_path, std::vector<Sarray>& a_Z )
{
  enum SfileOutputMode vars[5] = { RHO, P, S, QP, QS };
  int nvar = m_att ? 5 : 3;
  std::string fname;
  gen_fname(a_path, a_cycle, fname);

  for (int varid = 0; varid < nvar; varid++) {
    mMode = vars[varid];
    compute_image( a_U, a_Rho, a_Mu, a_Lambda, a_gRho, a_gMu, a_gLambda, a_Qp, a_Qs );
    write_image(fname.c_str(), a_Z );
  }
}

//-----------------------------------------------------------------------
void SfileOutput::compute_image( vector<Sarray>& a_U, vector<Sarray>& a_Rho,
                                 vector<Sarray>& a_Mu, vector<Sarray>& a_Lambda,
                                 vector<Sarray>& a_gRho, vector<Sarray>& a_gMu,
                                 vector<Sarray>& a_gLambda,
                                 vector<Sarray>& a_Qp, vector<Sarray>& a_Qs )
{
// Introduce 'st' to simplify the variable name
  int st = mImageSamplingFactor;
  for( int g=0 ; g < mEW->mNumberOfGrids ; g++ )
  {
    int il = mEW->m_iStart[g];
    int iu = mEW->m_iEnd[g];
    int jl = mEW->m_jStart[g];
    int ju = mEW->m_jEnd[g];
    int kl = mEW->m_kStart[g];
    int ku = mEW->m_kEnd[g];
    int ni = (iu-il+1);
    int nj = (ju-jl+1);

    float_sw4 *up = a_U[g].c_ptr();
    if( mMode == RHO )
      up = a_Rho[g].c_ptr();
    else if( mMode == MU )
      up = a_Mu[g].c_ptr();
    else if( mMode == LAMBDA )
      up = a_Lambda[g].c_ptr();
    else if( mMode == GRADRHO )
      up = a_gRho[g].c_ptr();
    else if( mMode == GRADMU )
      up = a_gMu[g].c_ptr();
    else if( mMode == GRADLAMBDA )
      up = a_gLambda[g].c_ptr();
    else if( mMode == QP )
      up = a_Qp[g].c_ptr();
    else if( mMode == QS )
      up = a_Qs[g].c_ptr();


    int niw = (mWindow[g][1]-mWindow[g][0])/st+1;
    int nijw=niw*((mWindow[g][3]-mWindow[g][2])/st+1);
    if( mMode == UX || mMode == UY || mMode == UZ )
    {
      int c  = 0;
      if( mMode == UY )
        c = 1;
      if( mMode == UZ )
        c = 2;
      if( m_double )
      {
        //	    for( int ks=0 ; ks <= (mWindow[g][5]-mWindow[g][4])/st ; ks++ )
        //	       for( int js=0 ; js <= (mWindow[g][3]-mWindow[g][2])/st ; js++ )
        //		  for( int is=0 ; is <= (mWindow[g][1]-mWindow[g][0])/st ; is++ )
        //		  {
        //		     int k = mWindow[g][4]+ks*st;
        //		     int j = mWindow[g][2]+js*st;
        //		     int i = mWindow[g][0]+is*st;
        //		     size_t ind = is+ni*js+nij*ks;
        //		     m_doubleField[g][ind]= a_U(c,i,j,k);
        //		  }
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind]= (double) a_U[g](c+1,i,j,k);
              //		     m_doubleField[g][ind] = up[c+ 3*((i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl))];
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = (float) a_U[g](c+1,i,j,k);
              //		     m_floatField[g][ind++] = up[c+ 3*((i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl))];
            }
      }
    }
    else if( mMode == RHO || mMode == MU || mMode == LAMBDA || mMode == GRADRHO || mMode == GRADMU || mMode == GRADLAMBDA
             || mMode == QP || mMode == QS ) // these modes just copy the values straight from the up array
    {
      if( m_double )
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind] = up[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)];
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = up[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)];
            }
      }
    }
    else if( mMode == P )
    {
      float_sw4* rho = a_Rho[g].c_ptr();
      float_sw4* mu  = a_Mu[g].c_ptr();
      float_sw4* la  = a_Lambda[g].c_ptr();
      if( m_double )
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind] = sqrt((2*mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] +
                                            la[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])/rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = sqrt((2*mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] +
                                           la[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])/rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
    }
    else if( mMode == S )
    {
      float_sw4* rho = a_Rho[g].c_ptr();
      float_sw4* mu  = a_Mu[g].c_ptr();
      if( m_double )
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind] = sqrt(mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]/
                                           rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = sqrt(mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]/
                                          rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
    }
    else if( mMode == GRADP )
    {
      float_sw4* rho = a_Rho[g].c_ptr();
      float_sw4* mu  = a_Mu[g].c_ptr();
      float_sw4* la  = a_Lambda[g].c_ptr();
      float_sw4* gla = a_gLambda[g].c_ptr();

      if( m_double )
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind] = 2*sqrt((2*mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] +
                                              la[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])*rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])
                                      *gla[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)];
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = 2*sqrt((2*mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] +
                                             la[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])*rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])
                                     *gla[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)];
            }
      }
    }
    else if( mMode == GRADS )
    {
      float_sw4* rho = a_Rho[g].c_ptr();
      float_sw4* mu  = a_Mu[g].c_ptr();
      float_sw4* gla = a_gLambda[g].c_ptr();
      float_sw4* gmu = a_gMu[g].c_ptr();

      if( m_double )
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_doubleField[g][ind] = sqrt(mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]*
                                           rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)])*(
                                        2*gmu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] - 4*gla[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
      else
      {
        #pragma omp parallel for
        for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
          for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
            for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
            {
              size_t ind = (i-mWindow[g][0])/st+niw*(j-mWindow[g][2])/st+nijw*(k-mWindow[g][4])/st;
              m_floatField[g][ind] = sqrt(  mu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]*
                                            rho[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] )*
                                     (2*gmu[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)] - 4*gla[(i-il)+ni*(j-jl)+((size_t)ni)*nj*(k-kl)]);
            }
      }
    }
    //Extrapolate extra point in z
    if( m_extraz[g] == 1 )
    {
      int k = mWindow[g][5]+st;
      size_t koff= ((size_t)(mWindow[g][1]-mWindow[g][0])/st+1)
                   *((mWindow[g][3]-mWindow[g][2])/st+1);
      size_t ind = (k-mWindow[g][4])/st*koff;

      // Linear extrapolation assumes that
      // mWindow[g][5]-st>=mWindow[g][4], i.e. mWindow[g][5] -mWindow[g][4]>=st.
      int ok = 2;
      if( mWindow[g][5] -mWindow[g][4] < st )
        ok = 1;

      if( m_double )
      {
        for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+= st )
          for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+= st )
          {
            m_doubleField[g][ind] = 2*m_doubleField[g][ind-koff]-m_doubleField[g][ind-ok*koff];
            ind++;
          }

      }
      else
      {
        for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+= st )
          for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+= st )
          {
            m_floatField[g][ind] = 2*m_floatField[g][ind-koff]-m_floatField[g][ind-ok*koff];
            ind++;
          }
      }
    }
  }
}

//-----------------------------------------------------------------------
void SfileOutput::gen_fname(std::string &path, int cycle, std::string& fname)
{
  fname = path;
  fname += mFilePrefix;
  fname += ".cycle=";
  int temp = static_cast<int>(pow(10.0, mPreceedZeros - 1));
  int testcycle = cycle;
  if (cycle == 0)
    testcycle=1;
  while (testcycle < temp)
  {
    fname += "0";
    temp /= 10;
  }
  fname += std::to_string(cycle);
  fname += ".sfile";
}

//-----------------------------------------------------------------------
void SfileOutput::write_image(const char *fname, std::vector<Sarray>& a_Z )
{
  std::string m_modestring;
  if( mMode == RHO )
    m_modestring = "Rho";
  else if( mMode == P )
    m_modestring = "Cp";
  else if( mMode == S )
    m_modestring = "Cs";
  else if( mMode == QP )
    m_modestring = "Qp";
  else if( mMode == QS )
    m_modestring = "Qs";
  if (m_parallel_io[0]->proc_zero())
    cout << "Start to write sfile " << m_modestring << std::endl;

#ifdef USE_HDF5
  hid_t h5_fid, grp, grp2, dset, attr, dtype, dspace, attr_space1, attr_space2, attr_space3, fapl;
  int ret;

  int ng = mEW->mNumberOfGrids;

  ASSERT(m_isDefinedMPIWriters);
  int gridinfo = 0;
  if( mEW->topographyExists() )
    gridinfo = 1;

  bool iwrite = false;
  for( int g=0 ; g < ng ; g++ )
    iwrite = iwrite || m_parallel_io[g]->i_write();

  int st = mImageSamplingFactor;

  // Open file from processor zero and write header.
  if( m_parallel_io[0]->proc_zero() && !m_isCreated )
  {
    hsize_t dims[3], dims1 = 1, dims2 = 2, dims3 = 3, total_elem = 0;
    setenv("HDF5_USE_FILE_LOCKING", "FALSE", 1);
    int alignment = 65536;
    fapl = H5Pcreate(H5P_FILE_ACCESS);
    H5Pset_alignment(fapl, alignment, alignment);

    h5_fid = H5Fcreate(fname, H5F_ACC_TRUNC, H5P_DEFAULT, fapl);
    if (h5_fid < 0)
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating HDF5 file " << fname << " for writing header");

    H5Pclose(fapl);
    std::cout << "writing Sfile to " << fname << std::endl;

    attr_space1 = H5Screate_simple(1, &dims1, NULL);
    attr_space2 = H5Screate_simple(1, &dims2, NULL);
    attr_space3 = H5Screate_simple(1, &dims3, NULL);

    char *aname;
    aname = "Origin longitude, latitude, azimuth";
    double lonlataz[3];
    lonlataz[0] = mEW->getLonOrigin();
    lonlataz[1] = mEW->getLatOrigin();
    lonlataz[2] = mEW->getGridAzimuth();
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_DOUBLE, attr_space3, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_DOUBLE, lonlataz);
    H5Aclose(attr);

    aname = "Coarsest horizontal grid spacing";
    double spacing = mEW->mGridSize[0]*mImageSamplingFactor;
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_DOUBLE, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_DOUBLE, &spacing);
    H5Aclose(attr);

    aname = "Attenuation";
    int att = mEW->usingAttenuation();
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_INT, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_INT, &att);
    H5Aclose(attr);

    aname = "ngrids";
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_INT, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_INT, &ng);
    H5Aclose(attr);

    aname = "Roworder";
    hbool_t sw4order = false;
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_HBOOL, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_INT, &sw4order);
    H5Aclose(attr);

    aname = "Min, max depth";
    double minmaxdp[2];
    minmaxdp[0] = mEW->getGlobalZmin();
    minmaxdp[1] = mEW->getGlobalZmax();
    attr = H5Acreate(h5_fid, aname, H5T_NATIVE_DOUBLE, attr_space2, H5P_DEFAULT, H5P_DEFAULT);
    if( attr < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
    H5Awrite(attr, H5T_NATIVE_DOUBLE, minmaxdp);
    H5Aclose(attr);


    grp = H5Gcreate(h5_fid, "Z_interfaces", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    if( grp < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating Z_interfaces");

    // Top interface (topo)
    char dname[128], gname[128];
    hsize_t globalSize[3];
    globalSize[0] = (mGlobalDims[ng-1][1]-mGlobalDims[ng-1][0])/st+1;
    globalSize[1] = (mGlobalDims[ng-1][3]-mGlobalDims[ng-1][2])/st+1;
    sprintf(dname, "z_values_%d", 0);

    dspace = H5Screate_simple(2, globalSize, NULL);
    hid_t dcpl;
    float intf = 0.0;
    // No topo fill all 0s to top interface
    dcpl = H5Pcreate(H5P_DATASET_CREATE);
    if (gridinfo == 0)
      H5Pset_fill_value(dcpl, H5T_NATIVE_FLOAT, &intf);
    dset = H5Dcreate(grp, dname, H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, dcpl, H5P_DEFAULT);

    H5Pclose(dcpl);
    H5Sclose(dspace);
    H5Dclose(dset);

    for(int g = ng-1; g >= 0; g--)
    {
      sprintf(dname, "z_values_%d", ng-g);
      double h = (double) mEW->mGridSize[g]*mImageSamplingFactor;
      globalSize[0] = (mGlobalDims[g][1]-mGlobalDims[g][0])/st+1;
      globalSize[1] = (mGlobalDims[g][3]-mGlobalDims[g][2])/st+1;

      dspace = H5Screate_simple(2, globalSize, NULL);
      dcpl = H5Pcreate(H5P_DATASET_CREATE);
      // Cartisian grid, just fill with a const value
      if (g <= mEW->mNumberOfCartesianGrids) {
        if (g == 0)
          intf = mEW->getGlobalZmax();
        else
          intf = mEW->m_zmin[g-1];
        std::cout << "Setting const z value to intf " << ng-g << " with " << intf << std::endl;
        H5Pset_fill_value(dcpl, H5T_NATIVE_FLOAT, &intf);
      }

      dset = H5Dcreate(grp, dname, H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, dcpl, H5P_DEFAULT);

      H5Pclose(dcpl);
      H5Sclose(dspace);
      H5Dclose(dset);
    }
    H5Gclose(grp);

    // Material
    grp = H5Gcreate(h5_fid, "Material_model", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    if( grp < 0 )
      VERIFY2(0, "ERROR: SfileOutput::write_image, error creating Material model group");

    for(int g = 0; g < ng ; g++ )
    {
      sprintf(gname, "grid_%d", ng-g-1);
      grp2 = H5Gcreate(grp, gname, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      if( grp2 < 0 )
        VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << gname);

      double h = (double) mEW->mGridSize[g]*mImageSamplingFactor;

      aname = "Horizontal grid size";
      attr = H5Acreate(grp2, aname, H5T_NATIVE_DOUBLE, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
      if( attr < 0 )
        VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
      H5Awrite(attr, H5T_NATIVE_DOUBLE, &h);
      H5Aclose(attr);

      aname = "Number of components";
      int ncomp = m_att ? 5 : 3;
      attr = H5Acreate(grp2, aname, H5T_NATIVE_INT, attr_space1, H5P_DEFAULT, H5P_DEFAULT);
      if( attr < 0 )
        VERIFY2(0, "ERROR: SfileOutput::write_image, error creating " << aname);
      H5Awrite(attr, H5T_NATIVE_INT, &ncomp);
      H5Aclose(attr);

      globalSize[0] = (mGlobalDims[g][1]-mGlobalDims[g][0])/st+1;
      globalSize[1] = (mGlobalDims[g][3]-mGlobalDims[g][2])/st+1;
      globalSize[2] = (mGlobalDims[g][5]-mGlobalDims[g][4])/st+1+m_extraz[g];
      dspace = H5Screate_simple(3, globalSize, NULL);

      dset = H5Dcreate(grp2, "Cp", H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      H5Dclose(dset);
      dset = H5Dcreate(grp2, "Cs", H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      H5Dclose(dset);
      dset = H5Dcreate(grp2, "Rho", H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
      H5Dclose(dset);
      if (m_att) {
        dset = H5Dcreate(grp2, "Qp", H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
        H5Dclose(dset);
        dset = H5Dcreate(grp2, "Qs", H5T_NATIVE_FLOAT, dspace, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
        H5Dclose(dset);
      }
      H5Sclose(dspace);
      H5Gclose(grp2);
    }

    H5Gclose(grp);

    // Top interface (topo)
    H5Sclose(attr_space1);
    H5Sclose(attr_space2);
    H5Sclose(attr_space3);
    H5Fclose(h5_fid);
    m_isCreated = true;
  }
  m_parallel_io[0]->writer_barrier();

  off_t offset = 0;
  // Write curvilinear interfaces
  if( gridinfo == 1 && m_modestring == "Rho")
  {
    offset = 0;
    for (int g = mEW->mNumberOfCartesianGrids; g < mEW->mNumberOfGrids; g++)
    {
      char dname[128];
      sprintf(dname, "z_values_%d", ng-g-1);

      float_sw4* zp = a_Z[g].c_ptr();
      size_t npts = ((size_t)(mGlobalDims[g][1]-mGlobalDims[g][0])/st+1)*
                    ((mGlobalDims[g][3]-mGlobalDims[g][2])/st+1)*
                    ((mGlobalDims[g][5]-mGlobalDims[g][4])/st+1+m_extraz[g]);

      if( !mEW->usingParallelFS() || g == 0 )
        m_parallel_io[g]->writer_barrier();

      size_t nptsloc  = ((size_t)(mWindow[g][1] - mWindow[g][0])/mImageSamplingFactor + 1)*
                        ( (mWindow[g][3] - mWindow[g][2])/mImageSamplingFactor + 1)*
                        ( (mWindow[g][5] - mWindow[g][4])/mImageSamplingFactor + 1 + m_extraz[g]);

      int ni = (mWindow[g][1]-mWindow[g][0])/st+1;
      int nij=ni*((mWindow[g][3]-mWindow[g][2])/st+1);
      /* if( m_double ) */
      /* { */
      /*    double* zfp = new double[nptsloc]; */
      /* #pragma omp parallel for */
      /* for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st ) */
      /* for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st ) */
      /* for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st ) */
      /* { */
      /* size_t ind = (i-mWindow[g][0])/st+ni*(j-mWindow[g][2])/st+nij*(k-mWindow[g][4])/st; */
      /* zfp[ind] = (double) a_Z[g](i,j,k); */
      /* } */
      /* //	 for( size_t i = 0; i < nptsloc ; i++ ) */
      /* //	    zfp[i] = zp[i]; */
      /*    char cprec[]="double"; */
      /*    m_parallel_io[g]->write_array_hdf5( fname, "Z_interfaces", dname, 1, zfp, offset, cprec ); */
      /*    delete[] zfp; */
      /* } */
      /* else */
      /* { */
      float* zfp = new float[nptsloc];
      #pragma omp parallel for
      for( int k=mWindow[g][4] ; k <= mWindow[g][5] ; k+=st )
        for( int j=mWindow[g][2] ; j <= mWindow[g][3] ; j+=st )
          for( int i=mWindow[g][0] ; i <= mWindow[g][1] ; i+=st )
          {
            size_t ind = (i-mWindow[g][0])/st+ni*(j-mWindow[g][2])/st+nij*(k-mWindow[g][4])/st;
            zfp[ind] = (float) a_Z[g](i,j,k);
          }
      //	 for( size_t i = 0; i < nptsloc ; i++ )
      //	    zfp[i] = zp[i];
      char cprec[]="float";
      m_parallel_io[g]->write_array_hdf5( fname, "Z_interfaces", dname, 1, zfp, offset, cprec );
      delete[] zfp;
      /* } */
    } // end for g (curvilinear)

  } // end if grid info

  // Write data blocks
  for( int g = 0 ; g < ng ; g++ )
  {
    size_t npts = ((size_t)(mGlobalDims[g][1]-mGlobalDims[g][0])/st+1)*
                  ((mGlobalDims[g][3]-mGlobalDims[g][2])/st+1)*
                  ((mGlobalDims[g][5]-mGlobalDims[g][4])/st+1+m_extraz[g]);

    if( !mEW->usingParallelFS() || g == 0 )
      m_parallel_io[g]->writer_barrier();

    // Sfile grid order is reverse of sw4 grid order
    char gname[128];
    sprintf(gname, "/Material_model/grid_%d", ng-g-1);
    // Debug
    if( m_parallel_io[0]->proc_zero() ) {
      std::cout << "Writing to [" << gname << "], [" << m_modestring << "]" << std::endl;
    }

    if( m_double ) {
      char cprec[]="double";
      m_parallel_io[g]->write_array_hdf5( fname, gname, m_modestring.c_str(), 1, m_doubleField[g], offset, cprec );
    }
    else {
      char cprec[]="float";
      m_parallel_io[g]->write_array_hdf5( fname, gname, m_modestring.c_str(), 1, m_floatField[g], offset, cprec );
    }
  }


#else
  cout << "ERROR: cannot write sfile without sw4 compiled with HDF5 library!" << endl;
#endif
}
